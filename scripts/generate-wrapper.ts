/**
 * generate-wrapper.ts
 *
 * Auto-generates denoboot/mod.ts for deno.land/x
 * by fetching all @denoboot packages from GitHub.
 *
 * Features:
 *  - Detects latest semver tag per package
 *  - Fallback to branch/main if no tag exists
 *  - Alphabetical export order
 *  - Includes wrapper version in header
 *  - Uses GitHub token if available to avoid rate limits
 *
 * WARNING: This file completely overwrites mod.ts every time it runs.
 */

const GITHUB_ORG = "denoboot";
const MAIN_REPO = "deno-boot";
const WRAPPER_REPO = "denoboot"; // your wrapper repo name
const BRANCH = "main";
const PACKAGES_PATH = "packages";

// GitHub token (optional) to avoid rate limit
const headers: HeadersInit = {
  "Accept": "application/vnd.github+json",
  ...(Deno.env.get("GITHUB_TOKEN")
    ? { "Authorization": `Bearer ${Deno.env.get("GITHUB_TOKEN")}` }
    : {})
};

// Simple semver compare
function compareSemver(a: string, b: string): number {
  const pa = a.split(".").map(Number);
  const pb = b.split(".").map(Number);
  for (let i = 0; i < 3; i++) {
    if (pa[i] > pb[i]) return 1;
    if (pa[i] < pb[i]) return -1;
  }
  return 0;
}

// Fetch wrapper version
async function getWrapperVersion(): Promise<string | null> {
  const res = await fetch(`https://api.github.com/repos/${GITHUB_ORG}/${WRAPPER_REPO}/tags`, { headers });
  if (!res.ok) return null;
  const tags: { name: string }[] = await res.json();
  const semverTags = tags.map(t => t.name).filter(t => /^v\d+\.\d+\.\d+$/.test(t));
  semverTags.sort((a, b) => compareSemver(b.slice(1), a.slice(1)));
  return semverTags[0] || null;
}

// Fetch all directories in packages
async function fetchPackages(): Promise<string[]> {
  const res = await fetch(`https://api.github.com/repos/${GITHUB_ORG}/${MAIN_REPO}/contents/${PACKAGES_PATH}?ref=${BRANCH}`, { headers });
  if (!res.ok) throw new Error(`Failed to fetch packages: ${res.status}`);
  const data: { name: string; type: string }[] = await res.json();
  return data.filter(d => d.type === "dir").map(d => d.name);
}

// Fetch deno.json for a package
async function fetchPackageName(pkg: string): Promise<string | null> {
  const url = `https://raw.githubusercontent.com/${GITHUB_ORG}/${MAIN_REPO}/${BRANCH}/${PACKAGES_PATH}/${pkg}/deno.json`;
  try {
    const res = await fetch(url, { headers });
    if (!res.ok) throw new Error(`Failed to fetch ${url}`);
    const json = await res.json();
    return json.name as string;
  } catch (err) {
    console.error(err);
    return null;
  }
}

// Fetch all repo tags once
async function fetchAllRepoTags(): Promise<string[]> {
  const res = await fetch(`https://api.github.com/repos/${GITHUB_ORG}/${MAIN_REPO}/tags`, { headers });
  if (!res.ok) throw new Error(`Failed to fetch repo tags: ${res.status}`);
  const tags: { name: string }[] = await res.json();
  return tags.map(t => t.name);
}

// Find latest semver tag for a package from pre-fetched tags
function findLatestPackageTag(pkg: string, tags: string[]): string | null {
  const matches: { tag: string; semver: string }[] = [];

  for (const tag of tags) {
    const match = tag.match(new RegExp(`^${pkg}[\\-@]?v?(\\d+\\.\\d+\\.\\d+)$`));
    if (match) matches.push({ tag, semver: match[1] });
  }

  if (matches.length === 0) return null;
  matches.sort((a, b) => compareSemver(b.semver, a.semver));
  return matches[0].tag;
}

// Main
async function generateWrapper() {
  const wrapperVersion = await getWrapperVersion() || "unreleased";
  const packages = await fetchPackages();
  const repoTags = await fetchAllRepoTags();

  const exportLines: string[] = [];

  for (const pkg of packages) {
    const name = await fetchPackageName(pkg);
    if (!name) continue;

    const tag = findLatestPackageTag(pkg, repoTags);
    if (tag) {
      exportLines.push(`export * from "jsr:${name}@${tag}";`);
    } else {
      exportLines.push(`export * from "jsr:${name}";`);
    }
  }

  exportLines.sort();

  const header = `// ------------------------------------------------------------
// THIS FILE IS AUTO-GENERATED by scripts/generate-wrapper.ts
// Wrapper version: ${wrapperVersion}
// Do not edit manually. Run the script to update.
// ------------------------------------------------------------\n\n`;

  const modContent = header + exportLines.join("\n") + "\n";

  await Deno.writeTextFile("mod.ts", modContent);
  console.log(`âœ… mod.ts wrapper generated! Wrapper version: ${wrapperVersion}`);
}

await generateWrapper();
